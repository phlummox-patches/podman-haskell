<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Podman.Tutorial</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Podman.Tutorial.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">podman-3.2.3.0: A podman remote client library</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Podman.Tutorial</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Introduction</a></li><li><a href="#g:2">Create the client</a></li><li><a href="#g:3">Call endpoint</a></li><li><a href="#g:4">Copy files</a></li><li><a href="#g:5">Use interactive session</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>The <code>podman</code> library provides a simple interface for interacting with a podman API.
 Use this library to validate the API and integrate podman in Haskell applications.</p><p>This tutorial introduces how to use the <code>podman</code> library to write Haskell scripts.</p><p>In another terminal, ensure the API is running:</p><pre>$ podman --log-level=debug system service --time=0 /var/run/podman.sock</pre></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Introduction</h1></a><div class="doc"><p>To start using this library you need a haskell toolchain, on fedora run:</p><pre>$ sudo dnf install -y ghc cabal-install &amp;&amp; cabal update</pre><p>Then get a copy of the library by running:</p><pre>$ git clone https://github.com/softwarefactory-project/podman-haskell
$ cd podman-haskell</pre><p>Install the library by running:</p><pre>$ cabal install --lib podman</pre><p>Validate the library is correctly installed by running:</p><pre>$ ghci
Prelude&gt; import Podman
Prelude Podman&gt; :set prompt &quot;&gt; &quot;
&gt; :set -XOverloadedStrings
&gt; withClient &quot;http+unix://var/run/podman.sock&quot; getVersion
Right (Version {_versionApiVersion = &quot;1.40&quot;, _versionVersion = &quot;3.1.0-dev&quot;})</pre></div><a href="#g:2" id="g:2"><h1>Create the client</h1></a><div class="doc"><p>Most functions require an existing <code><a href="Podman.html#v:PodmanClient" title="Podman">PodmanClient</a></code> which carries the
   endpoint url and the http client manager.</p><p>The only way to get the client is through the <code><a href="Podman.html#v:withClient" title="Podman">withClient</a></code> function, which
   uses a callback function. To make this easier to use in ghci, create this
   helper:</p><pre>&gt; let c = withClient &quot;http+unix://var/run/podman.sock&quot;
&gt; c $ \client -&gt; getVersion client</pre></div><a href="#g:3" id="g:3"><h1>Call endpoint</h1></a><div class="doc"><p>API functions operate with Haskell record, e.g.: <code><a href="Podman-Types.html#v:InspectContainerResponse" title="Podman.Types">InspectContainerResponse</a></code>.
   Each field is a function that can be used with the record:</p><pre>&gt; :type _inspectContainerResponseImageName
_inspectContainerResponseImageName :: InspectContainerResponse -&gt; Text</pre><p>For example, to inspect a container named &quot;podman-demo&quot;, use <code><a href="Podman.html#v:containerInspect" title="Podman">containerInspect</a></code>:</p><pre>&gt; Right res &lt;- c $ \client -&gt; containerInspect client (ContainerName &quot;podman-demo&quot;) False
&gt; :t res
res :: InspectContainerResponse
&gt; _inspectContainerResponseImageName res
&quot;registry.access.redhat.com/ubi8/ubi&quot;</pre><p>When an API endpoint has complex arguments, the library function also use records:</p><ul><li>When all the fields are optional, the library provides a default record, e.g. <code><a href="Podman-Types.html#v:defaultContainerListQuery" title="Podman.Types">defaultContainerListQuery</a></code>.</li><li>When some fields are required, the library provides a smart constructor, e.g. <code><a href="Podman-Types.html#v:mkSpecGenerator" title="Podman.Types">mkSpecGenerator</a></code>.</li></ul><p>Then the default fields can be modified using the record update syntax:</p><pre>&gt; let myListQuery = defaultContainerListQuery { _containerListQueryall = Just True }
&gt; c $ \client -&gt; containerList client myListQuery
Right [ListContainer {...}, ...]</pre><p>The field name can be used in a mapping function, for example, to get the name of
   all the containers:</p><pre>&gt; (fmap . fmap . fmap $ _listContainerNames) &lt;$&gt; c $ \client -&gt; containerList client myListQuery
Right [&quot;podman-demo&quot;, &quot;rootless-cni-infra&quot;, &quot;...&quot;]</pre><p>Note that we use multiple <code><a href="../base-4.12.0.0/Data-Functor.html#v:fmap" title="Data.Functor">fmap</a></code> to penetrate each layer, e.g. MonadIO, Result, and List.</p></div><a href="#g:4" id="g:4"><h1>Copy files</h1></a><div class="doc"><p>The send and get files expect <code>tar</code> files, so first import the library and define a utility function:</p><pre>&gt; import qualified Codec.Archive.Tar as Tar
&gt; import qualified Codec.Archive.Tar.Entry as Tar
&gt; let tar = mapM (\(path, content) -&gt; Tar.fileEntry &lt;$&gt; Tar.toTarPath False path &lt;*&gt; pure content)</pre><p>Send files with <code><a href="Podman.html#v:containerSendFiles" title="Podman">containerSendFiles</a></code>:</p><pre>&gt; let Right tarball = tar [(&quot;test.dat&quot;, &quot;test-content&quot;)]
&gt; c $ \client -&gt; containerSendFiles client (ContainerName &quot;demo-haskell&quot;) tarball &quot;/tmp/test&quot; Nothing</pre><p>Get files with <code><a href="Podman.html#v:containerGetFiles" title="Podman">containerGetFiles</a></code>:</p><pre>&gt; c $ \client -&gt; containerGetFiles client (ContainerName &quot;demo-haskell&quot;) &quot;/tmp/test&quot;
Right (Next (Entry {entryTarPath = &quot;test&quot;, entryContent = Directory, ..}))</pre></div><a href="#g:5" id="g:5"><h1>Use interactive session</h1></a><div class="doc"><p>The interactive functions expect a callback, for example, to get a container log with <code><a href="Podman.html#v:containerLogs" title="Podman">containerLogs</a></code>:</p><pre>&gt; c $ \client -&gt; containerLogs client (ContainerName &quot;demo-haskell&quot;) LogBoth (defaultLogsQuery {_logsQueryfollow = Just follow}) print
Stdout &quot;container output&quot;
Stdout &quot;...&quot;</pre><p>The <code><a href="Podman.html#v:containerAttach" title="Podman">containerAttach</a></code> function provides a <code><a href="Podman.html#v:ContainerConnection" title="Podman">ContainerConnection</a></code> handler that can be used to read and write.
   Checkout the podman-demo script for more detailed examples.</p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.22.0</p></div></body></html>